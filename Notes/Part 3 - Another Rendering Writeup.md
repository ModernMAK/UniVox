Previously I wrote about how Atlasses will reduce draw calls by alot. However, prototyping is hard and slow if i have to generate an atlas. So the first topic to adress is atlases.

A Compromise? Or Missing Feature
One of the biggest things I didn't setup yet when I was planning on adding atlasses was storing atlas boundaries. Atlas boundaries allow us to pick a specific region in the atlas to use.

Trouble is, how do we impliment this atlas boundary? My gut tells me another index (which is fun because thats another index to keep track of). Although, this would have to be a sub-index, as it is only valid for the given Atlas.

Another problem that comes to mind is batching. Batches themselves shouldn't change, since we just use the same atlas. But Planar grouping does need to know if the atlas index is the same.

So to summarize, we now have 3 IDS per face, a MOD ID, a MATERIAL ID, and an ATLAS ID.
Why?
I imagine a Mod ID can help to reuse names. Material ID (technically the ID of the atlas to use) fetches the correct material to use, and Atlas ID determines which cell to use.

This brings up the problem of Non-Atlassed Materials, which only need the Mod and Material Id. This could be a seperate bank, but I think it would be easier to keep them the same and have a flag for nonatlassed.


I suppose this is now more about lookup table. So here I go.

Things that we need to reference are Meshes, Materials, Blocks. (Definately more)
Meshes are for entites as blocks are generated by the engine. Materials are wierd, because I dont think 'Entities' want anything to do with Atlasses, where as blocks want to be flexible.

So We have something like this
A Master Registry which accepts a MOD Id, something like Mods[ModID]

Inside we have several Sub-Registries; Meshes, Materials, Blocks.
Now we have Mods[ModID].Meshes[MeshID], Mods[ModID].Materials[MaterialID], and Mods[ModID].Blocks[BlockID]

In addition, Materials are two parts, Atlas Regions and the Material itself, Mods[ModID].Materials[MaterialID].Regions[RegionID] and  Mods[ModID].Materials[MaterialID].Value

In Summary (For Now);
Mods[ModID]
	Meshes[MeshID]
	Materials[MaterialID]
		Value
		Regions[RegionID]
	Blocks[BlockID]
	Entity[EntityID]

so now we store Meshes and Materials so they can be used in systems.

We also have Blocks and Entites which are used for logic; from converting Data to Render Information. Because BlockID doesn't translate to MaterialID.